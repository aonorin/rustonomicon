% Трансмутации

Уберись с нашей дороги, система типов! Мы будем интерпретировать эти биты по-
своему или умрем пытаясь! Хоть эта книга и про создание небезопасных вещей, я
действительно не могу не подчеркнуть, что вы должны глубоко задуматься над
поиском Другого способа, кроме того, что рассматривается в этом разделе. Это
действительно, по-настоящему, самая ужасно небезопасная вещь, которую вы можете
сделать в Rust. Это как если бы железнодорожное полотно охраняла зубная нить.

`mem::transmute<T, U>` берет значение типа `T` и интерпретирует как тип `U`. 
Единственное ограничение - размер `T` и `U` должен совпадать. Варианты, которые 
вызывают Неопределенное Поведение этим, сводят с ума.

* Первое и самое главное, создание экземпляра *любого* типа с неправильным 
состоянием вызовет огромный хаос, который невозможно предсказать.
* Трансмутация имеет перегруженный тип возврата. Если вы не укажете тип возврата
 она создаст какой-то удивительный тип, удовлетворяющий вывод типов.
* Создание примитива с неправильным значением - это неопределённое поведение (НП)
* Трансмутации между non-repr(C) типами - это НП
* Трансмутации & в &mut - это НП
    * Трансмутации & в &mut - это *всегда* НП
    * Нет, ты не можешь так делать
    * Нет, ты не особенный
* Трансмутации в ссылку без явного указания времени жизни создает [безграничное
 время жизни]

`mem::transmute_copy<T, U>` каким-то образом стал *даже более дико* небезопасным
 чем это. Он копирует `size_of<U>` байтов из `&T` и интерпретирует их как `U`. 
 Проверка длины, которая была у  `mem::transmute` пропала (потому что может быть
  допустимо копировать префикс), хотя если `U` длиннее, чем `T` - это 
  Неопределенное Поведение.

Вы также можете получить большую часть этой функциональности, используя явное
приведение указателей.


[unbounded lifetime]: unbounded-lifetimes.html
