% Как относятся Безопасный и Небезопасный Rust

Итак, каковы отношения между Безопасным и Небезопасным Rust? Как они
взаимодействуют?

Rust осуществляет разделение между Безопасным и Небезопасным Rust ключевым
словом `unsafe`, которое можно трактовать как *интерфейс внешних функций
(foreign function interface)* (FFI) между Безопасным и Небезопасным Rust. Это
магия, благодаря которой можно сказать, что Безопасный Rust - действительно
безопасен: вся работа со страшными небезопасными частями языка отводится 
исключительно FFI, *как с любым другим безопасным языком*.

Но из-за того, что один язык, получается, входит в другой, их можно спокойно
смешивать, обозначая границы между ними ключевым словом `unsafe`. Не надо писать
заголовочные файлы, инициализировать среду исполнения или делать какие-либо 
другие рутинные операции по обработке FFI.

Сегодня есть несколько мест, где может появиться `unsafe` в Rust, которые грубо
можно разделить на две категории:

* Этот контракт не проверяется. Чтобы убедиться, что вы, его пользователь, поняли 
это, я, автор контракта, требую писать `unsafe` в следующих случаях:     
  * Перед функциями `unsafe` показывает, что ее вызывать небезопасно. 
  Пользователи должны посмотреть документацию, чтобы определить, что это значит,
   и написать `unsafe`, чтобы подтвердить, что они знают об опасности.     
  * Перед объявлением типажей `unsafe` показывает, что *реализация* типажа 
  является небезопасной операцией, потому что у него есть контракты, которым 
  другой небезопасный код имеет право слепо доверять. (Больше об этом ниже.)

* Я заявляю, в меру своих знаний, что придерживаюсь следующей логики применения 
непроверенных контрактов:
  * В реализации типажей `unsafe` показывает, что соблюдается контракт типажа
`unsafe`.
  * В блоках `unsafe` показывает, что любая работа с небезопасными операциями 
  должна обрабатываться внутри, и, следовательно, родительская функция 
  безопасна.

Также есть флаг `#[unsafe_no_drop_flag]`, являющийся особым случаем,
присутствующим по историческим причинам и находящимся на пути к выпиливанию.
Смотри раздел [drop flags] для уточнения.

Примеры небезопасных функций:

* `slice::get_unchecked` выполняет непроверенное индексирование, позволяющее
свободно нарушить безопасность памяти. 
* любой сырой указатель на тип фиксированного размера обладает внутренним 
методом `offset`, который вызывает Неопределенное Поведение, если находится 
"вне границ", как определено LLVM. 
* `mem::transmute` интерпретирует значение полученного типа как другого типа, 
самовольно обходя безопасность типов. (смотри [conversions] для уточнения) 
* Все функции FFI являются `unsafe`, потому что могут выполнять произвольные 
сценарии. Си часто является очевидным виновником этого, но вообще-то любой язык
 может сделать то, от чего Rust будет не в восторге.

В Rust 1.0 есть ровно два небезопасных типажа:

* `Send` - это маркерный типаж (у него нет своего API), который обещает, что 
типы, реализующие его, можно можно безопасно посылать (перемещать) в другой поток.
* `Sync` - это маркерный типаж, который обещает, что потоки могут безопасно 
делить между собой типы, реализующие его, используя общую ссылку на него.

Необходимость в небезопасных типажах кроется в основных свойствах безопасного
кода:

**Каким бы убогим ни был Безопасный код, он не сможет вызвать Неопределенное
поведение.**

Это означает, что Небезопасный Rust, **передовой отряд неопределенного поведения**, 
должен *очень подозрительно* относиться к обобщенному безопасному коду. Для ясности, 
Небезопасный Rust абсолютно доверяет конкретному безопасному коду. Любое другое 
поведение выродилось бы для негов бесконечные спирали параноидального отчаяния. 
В частности, обычно нормальным считается доверять корректности стандартной библиотеки. 
`std` - это, по сути, расширение языка, и вам, действительно, следует доверять ему. 
Если `std` нарушает свои гарантии, тогда это точно ошибка в языке.

Тем не менее, лучше минимизировать напрасные надежды на железобетонность
безопасного кода. Ошибки случаются! Я ещё раз подчеркну: беспокоиться надо
только за Небезопасный код. Безопасный код может слепо верить всему, что не 
нарушает безопасность памяти.

С другой стороны, безопасные типажи могут свободно объявлять произвольные
контракты, но поскольку реализовывать их считается безопасным, небезопасный 
код не может считать, что эти контракты будут на самом деле соблюдаться. Это
так, потому что *кто угодно* может реализовать интерфейс, как он хочет. 
В этом и состоит фундаментальная разница, доверять ли правильности конкретного 
участка кода или доверять правильности *любого кода, который будет когда либо написан*.

Например, в Rust есть типажи `PartialOrd` и `Ord`, нужные для того, чтобы можно
было отличить типы, которые можно "только" сравнивать, от тех, значения которых 
находятся в отношении строгого порядка. В большинстве своем, каждое API,
которое хочет работать со сравнимыми данными, хочет иметь `Ord`. Например,
упорядоченный словарь вроде BTreeMap *не имеет никакого смысла* создавать для частично
упорядоченных данных. Если вы объявите, что тип реализует `Ord`, но не
предоставите значения, которые действительно находятся в отношении строгого порядка, 
BTreeMap *сядет в лужу* и начнет делать с собой разные плохие вещи. Вставленные данные 
будет уже невозможно найти!

Но это еще нормально. BTreeMap безопасен, поэтому он гарантирует, что даже если
вы дадите ему абсолютно бредовую реализацию `Ord`, он будет все равно делать
что-то *безопасное*. Он не начнет читать неинициализированную или
невыделенную память. На самом деле, BTreeMap даже не потеряет ваши данные. После
его удаления, все деструкторы будут вызваны успешно! Ура!

Однако BTreeMap реализован с использованием маленькой щепотки Небезопасного Rust
(как и большинство коллекций). Поэтому не всегда можно утверждать, что плохая 
реализация `Ord` не приведёт к небезопасному поведению BTreeMap. BTreeMap не 
должен полагаться на `Ord`, *ставя под угрозу безопасность*. `Ord` 
предоставляется безопасным кодом, а безопасный код считает всё безопасным.

Но правда было бы здорово, если бы небезопасный код мог бы в *каких-нибудь
местах* доверять контрактам типажа? Эта проблема, которой занимаются
небезопасные типажи: помечая небезопасность реализации *самого типажа*,
небезопасный код может доверять реализациям контракта типажа. Хотя она может и
не быть правильной во всех произвольных случаях.

Например, имея гипотетический типаж UnsafeOrd, технически будет правильна такая
реализация:

```rust
# use std::cmp::Ordering;
# struct MyType;
# unsafe trait UnsafeOrd { fn cmp(&self, other: &Self) -> Ordering; }
unsafe impl UnsafeOrd for MyType {
    fn cmp(&self, other: &Self) -> Ordering {
        Ordering::Equal
    }
}
```

Но, наверное, это совсем не та реализация, которая вам нужна.

Rust традиционно избегает делать типажи небезопасными по умолчанию, потому что 
это сделало бы небезопасность повсеместной, что нежелательно. Send и Sync небезопасны,
потому что потокобезопасность - *фундаментальное свойство*, от которого
небезопасный код даже не может попытаться защититься тем же образом, как он защитился 
бы от плохой реализации Ord. Единственный способ как
можно защититься от потоконебезопасности - *не использовать потоки вообще*.
Сделать каждую загрузку и сохранение атомарными тоже недостаточно, потому что могут 
существовать сложные варианты, задействующие отдельные области памяти.
Например, указатель и размер у Vec должны быть синхронизированы.

Даже такая парадигма параллельности, которая традиционно считается Абсолютно
Безопасной, как обмен сообщениями, неявно опирается на потокобезопасность -
действительно ли вы используете обмен сообщениями, если вы передаете указатель?
Для Send и Sync, таким образом, требуется фундаментальный уровень доверия,
который Безопасный код не может предоставить, поэтому их реализацию необходимо
сделать небезопасной. Чтобы избежать проникающей везде небезопасности, которая
возникнет вследствие этого, Send (или Sync) автоматически выводится для всех
типов, состоящих из значений типов, уже реализующих Send (или Sync). 
99% типов являются Send и Sync, и 99% из них никогда не сообщают об этом 
(оставшийся 1% - это по большей части примитивы синхронизации).




[drop flags]: drop-flags.html
[conversions]: conversions.html
